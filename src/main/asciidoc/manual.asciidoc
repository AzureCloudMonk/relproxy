// :icons: font es necesario para que se considere en la generación de HTML usando Font Awesome en donde palabras especiales son iconos por ej en "NOTE:" "IMPORTANT:" etc 
:icons: font  
// :linkcss: por defecto está definida por si acaso, para linkar asciidoctor.css
:linkcss:
// :copycss: es para que copie el asciidoctor.css por defecto junto al HTML generado
:copycss:
// :sectanchors: para mostrar un link de "posicionar" arriba cada título
:sectanchors:
:toc2:
// usamos highlightjs o prettify porque coderay falla (aunque está incluido)
:source-highlighter: prettify

= RelProxy
(C) Jose María Arranz Santamaría
v0.8

Because Java is also a dynamic language and Groovy can remain a dynamic language in a Java based environment.

== The origins of RelProxy

RelProxy was born as the result of the intent of providing a way to hot class reloading for the http://www.itsnat.org[ItsNat] Java web framework. 

ItsNat templates are pure X/HTML/SVG files with no logic executed in server, when a template is changed ItsNat automatically reloads the file and the new version is used 
in the next attempt of using the template. View logic is coded in Java by using Java W3C DOM APIs modifying ItsNat templates and finally generating the required markup in load
time or JavaScript code as the result of AJAX events.

As said before, ItsNat provided hot reloading of markup templates but view logic, coded in Java, remained too static, if you needed to change the view logic you needed to redeploy
the web application (in the best case only the web context is reloaded). Providing some hot class reloading of view logic (coded in Java or Groovy as we will see later) would dramatically increase
the productivity of ItsNat in development and in an edge case, view logic changes would be possible in production.

Redeploying is not strange to Java web developers when you leave the world of JSPs, JSPs were designed to be hot reloaded including logic coded in Java, many server centric frameworks
provides some kind of hot reloading templating, but in most of them Java code is not hot reloaded.

For ItsNat we needed some way to be able to hot reload view logic. The first attempt was trying to use Groovy in ItsNat, many people think Groovy is an "interpreted" language and is not, 
Groovy is also a language compiled to bytecode, but compilation happens on demand, generated bytecode is usually more flexible ("dynamic") than conventional Java and hot class reloading is built-in.
The problem of using Groovy in ItsNat was the need of registering Groovy listeners in ItsNat Java listeners (view processors), when registering
on an ItsNat (Java) listener the object registered is "frozen" and cannot be reloaded...

This was the context to invent RelProxy and is the reason of the name, Reload + Proxy, the first feature of RelProxy was creating Java proxies (+java.lang.reflect.Proxy+) to wrap Groovy objects before registering
into Java methods (ItsNat listeners), RelProxy proxies ever use the last version of the Groovy class by using the hot class loader of Groovy, by this way we can hot class reload classes in ItsNat... coded in Groovy.

The next step is obvious, Groovy class reloader is also a Groovy "compiler on demand", if we are able to make a "compiler on demand" for Java we can get THE SAME AS Groovy provides... in Java.
As you know, as of Java 1.6 we have a http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html[Java API] to access the compiler of your JDK.

If we are able to compile and load on demand Java source files, we can be more ambitious and be able to execute Java programs with no need of a previous compilation, and with no 
much problem package the start Java code like a UNIX shell script in a similar way http://groovy.codehaus.org/Running[Groovy does], providing maybe the fastest "scripting" language of the world. 

Why are you going to need Java as a scripting/shell language? 

Because:

. Java is faaaast
. Java is robust: because there is compilation on the fly, syntax errors are detected with no need of executing the offending code.
. Java has an enormous amount of libraries
. class files can be optionally automatically saved to avoid compilation in the next execution
. Java 8 is around the corner providing a less verbose language

If you can execute uncompiled Java code, is there something similar to an interactive shell to execute Java code snippets? Yes of course.

Finally, do not confuse Java scripting provided by RelProxy with http://www.beanshell.org/[BeanShell], BeanShell is NOT Java, is a scripting language heavily inspired on Java < 1.5, 
for instance in BeanShell there is no support of Java 1.5 features like generics .

That is all, welcome to dynamic Java, welcome to a more dynamic Groovy in a Java environment.
 
== What is RelProxy 

RelProxy is:

. A simple Java and Groovy hot class reloader for Java and Groovy providing transparent compilation and class reload on the fly with no need of a bootstrap class loader agent.
. A scripting environment to execute Java code snippets the same as a shell script, there is no new language, is Java compiled on the fly, code in the initial archive can call 
to other normal Java files. Optionally .class can be saved in a cache to provide *the fastest "scripting" language* of the world.
. Execution of Java code snippets in command line (no need of packaging into an archive).
. A simple shell to code, edit and execute code snippets in Java interactively.

== Requisites and installation

RelProxy requires JDK 1.6 or upper, RelProxy have been tested on Oracle JDK 1.6 and OpenJDK 1.7.

RelProxy distribution file has two important files:

. relproxy-X.X.jar : needed in classpath to use RelProxy in any form. 
. jproxysh : whether command line scripting capabilities are going to be used.


== GProxy or how to be able to reload Groovy classes on Java environment

+com.innowhere.relproxy.gproxy.GProxy+ is the main Java class of RelProxy to provide this feature, with +GProxy+ you can create Java proxies for Groovy objects because 
a +java.lang.reflect.Proxy+ wrapper is passed instead of the original Groovy object, the original Groovy object is retained under the hood and method calls to the proxy 
are redirected to the real object calling the corresponding method using reflection. When the source code of the Groovy class changes GProxy automatically reloads the Groovy 
class and creates a new object to replace the old one, the fields of the original object are got and re-set to the new object to keep the state (number of fields and types 
must be the same otherwise reloading is not possible and a redeploy is required).

The following code is an example of how to use RelProxy along with ItsNat web framework, this code is part of the example code of RelProxy source code. 



The +servlet+ variable is a servlet object containing a just configured +groovy.util.GroovyScriptEngine+, the setting up of this util object is omitted: 


[source,groovy]
.groovy_servlet_init.groovy
----
package example.groovyex;

import org.itsnat.core.http.ItsNatHttpServlet;
import org.itsnat.core.tmpl.ItsNatDocumentTemplate;
import org.itsnat.core.event.ItsNatServletRequestListener;
import groovy.util.GroovyScriptEngine;
import java.lang.reflect.Method;
import com.innowhere.relproxy.RelProxyOnReloadListener;
import com.innowhere.relproxy.gproxy.GProxy;
import com.innowhere.relproxy.gproxy.GProxyGroovyScriptEngine;
import com.innowhere.relproxy.gproxy.GProxyConfig;


GroovyScriptEngine groovyEngine = servlet.getGroovyScriptEngine();

def gproxyGroovyEngine = {
             String scriptName -> return (java.lang.Class)groovyEngine.loadScriptByName(scriptName) 
        } as GProxyGroovyScriptEngine;

def reloadListener = { 
        Object objOld,Object objNew,Object proxy, Method method, Object[] args -> 
           println("Reloaded " + objNew + " Calling method: " + method)
      } as RelProxyOnReloadListener;

def gpConfig = GProxy.createGProxyConfig();
gpConfig.setEnabled(true)
        .setRelProxyOnReloadListener(reloadListener)
        .setGProxyGroovyScriptEngine(gproxyGroovyEngine);

GProxy.init(gpConfig);


String pathPrefix = context.getRealPath("/") + "/WEB-INF/groovyex/pages/";

def docTemplate;
docTemplate = itsNatServlet.registerItsNatDocumentTemplate("groovyex","text/html", pathPrefix + "groovyex.html");

def db = new FalseDB();

ItsNatServletRequestListener listener = GProxy.create(new example.groovyex.GroovyExampleLoadListener(db), ItsNatServletRequestListener.class);
docTemplate.addItsNatServletRequestListener(listener);

----


Let's explain the previous code:

[source,groovy]
----
def gproxyGroovyEngine = {
             String scriptName -> return (java.lang.Class)groovyEngine.loadScriptByName(scriptName) 
        } as GProxyGroovyScriptEngine;
----

Defines a listener needed by GProxy to indirectly call the +groovy.util.GroovyScriptEngine+ to load classes, take a look to the signature of +GProxyGroovyScriptEngine+ there is no dependency
with +groovy.*+ packages, this is why you can use RelProxy in pure Java projects with no Groovy dependency in spite of Groovy support.


[source,groovy]
----
def reloadListener = { 
        Object objOld,Object objNew,Object proxy, Method method, Object[] args -> 
           println("Reloaded " + objNew + " Calling method: " + method)
      } as RelProxyOnReloadListener;
----

Defines an optional listener to be called when a Groovy class is reloaded, the listener receives the old and new object cause of reloading because a proxied method was called.

[source,groovy]
----
def gpConfig = GProxy.createGProxyConfig();
gpConfig.setEnabled(true)
        .setRelProxyOnReloadListener(reloadListener)
        .setGProxyGroovyScriptEngine(gproxyGroovyEngine);

GProxy.init(gpConfig);
----

Configures +GProxy+, now it is ready to proxy Groovy objects.

Take a look to the optional +setEnabled(true)+ configuration call, +GProxy+ is enabled by default, this means proxied Groovy objects are instrumented for hot reload. 
Calling +setEnabled(false)+ tells +GProxy+ to ignore any other configuration, +GProxy+ is disabled and no proxy is created, the original Groovy objects will be returned with absolute no performance penalty,
this is the preferred configuration in production whether you do not want hot class reload in production.

The final code:

[source,groovy]
----
def db = new FalseDB();

ItsNatServletRequestListener listener = GProxy.create(new example.groovyex.GroovyExampleLoadListener(db), ItsNatServletRequestListener.class);
docTemplate.addItsNatServletRequestListener(listener);
----

is an example of proxying a +example.groovyex.GroovyExampleLoadListener+ object and registering the returned Java proxy into the ItsNat infrastructure. 
The class +example.groovyex.GroovyExampleLoadListener+ implements the ItsNat standard interface +ItsNatServletRequestListener+ implementing the method
+processRequest(ItsNatServletRequest request, ItsNatServletResponse response)+ this method is called by ItsNat, the proxy object receives this call and forwards this call
to the latest class loaded, we are going to see more details later.

Let's go to take a look to +example.groovyex.GroovyExampleLoadListener+:

[source,groovy]
.GroovyExampleLoadListener.groovy
----
package example.groovyex;

import org.itsnat.core.event.ItsNatServletRequestListener;
import org.itsnat.core.ItsNatServletRequest;
import org.itsnat.core.ItsNatServletResponse;
import example.groovyex.FalseDB;

class GroovyExampleLoadListener implements ItsNatServletRequestListener
{
    def db

    GroovyExampleLoadListener() 
    { 
    }
    
    GroovyExampleLoadListener(FalseDB db) // Explicit type tells Groovy to reload FalseDB class when changed
    {
        this.db = db;
    }

    void processRequest(ItsNatServletRequest request, ItsNatServletResponse response)
    { 
        println("GroovyExampleLoadListener 4 ");
        
        new example.groovyex.GroovyExampleDocument(request.getItsNatDocument(),db);
    }
}
----

To understand this code let's to explain how ItsNat works, the method +processRequest+ is called every time a page is loaded specifying the same ItsNat template, 
because this listener was registered as the load processor.

When RelProxy (through +groovy.util.GroovyScriptEngine+) detects the source code of the class +GroovyExampleLoadListener+ or dependent classes like +GroovyExampleDocument+ have 
changed, all classes with associated hot reloadable source, are reloaded and a new +ClassLoader+ is created for them, next calls to +GroovyExampleLoadListener+ proxy will use the new loaded class and the same
with dependent classes.

However a concrete +GroovyExampleLoadListener+ object was used to register, how can we reload a class with one alive object already created?

The +GroovyExampleLoadListener+ object was the one proxied, the class of this object is reloaded when a source change is detected (or any related class) because this is the objective of RelProxy, 
but this object can have fields pointing to objects usually loaded _before_ registering/proxying the +GroovyExampleLoadListener+ object. The classes of these attribute
objects may be also reloaded but the new version is not effective because pointed objects are usually being used in other places, if we re-create these objects
we are creating new instances for instance of objects designed to be singletons. This is the case of the +db+ attribute of 
class +FalseDB+, this attribute references a concrete +FalseDB+ object not able to be automatically reloaded in spite of the Groovy +FalseDB+ class could be reloaded. 
This is why in case of the proxied object +GroovyExampleLoadListener+, RelProxy recreates the object based on the new loaded class by calling the default constructor and *re-setting the attributes*, 
by this way the new object is based on the new class containing the same attribute objects defined before, you cannot add, remove or change the type of attributes if you do so RelProxy 
will not be able to hot reload and a new redeploy is needed.

The proxied class usually creates new objects based on dependent classes to execute some task, if no object of these dependent classes is "saved" and/or used outside of proxied environment
RelProxy can reload dependent classes with no problem.

This is the case of the class +GroovyExampleDocument+ and dependent classes (see the source code).

Other classes and interfaces like +ItsNatServletRequest+ or +ItsNatServletResponse+ are not reloaded in this example because they are ItsNat based and source code is not
present in Groovy environment. +FalseDB+ class could be reloaded but reloading will fail because the proxied object (+GroovyExampleLoadListener+) holds an attribute +db+ of this class, RelProxy 
will say you the reloading process has been failed and a redeploy is recommended to effectively use the new version of the class.

In summary, in this ItsNat example, when source code of +GroovyExampleLoadListener+ or dependent classes with source code controlled by RelProxy changes, all of these classes are reloaded.
When the +processRequest+ method of the proxied +GroovyExampleLoadListener+ object is called because an end user is reloading the related web page, RelProxy detects this class has been reloaded and 
recreates the +GroovyExampleLoadListener+ object with the new class re-setting the fields and finally the +processRequest+ method is called and method processing is done
using the new version of dependent classes.

Finally we have been able to reload Groovy classes mixed in a Java environment without using the strongly intrusive instrument of Java agents.

== JProxy or how to be able to reload Java classes without using Java agents

Java hot reloadable proxies are very similar to Groovy support of RelProxy, in this case the task of detecting source changes, recompiling and reloading is fully done by RelProxy
(in case of Groovy provided +groovy.util.GroovyScriptEngine+ does most of this work).

+com.innowhere.relproxy.jproxy.JProxy+ is the main Java class of RelProxy for hot reload of pure Java, with JProxy you can create Java +java.lang.reflect.Proxy+ proxies wrapping
your original objects to be passed to listeners, the original object is retained under the hood and method calls to the proxy are redirected to the real object calling the 
corresponding method using reflection. When the source code of the proxied Java class (or dependent classes) changes JProxy automatically reloads the class and creates a 
new object to replace the old one, the fields of the original object are got and re-set to the new object to keep the state (number of fields and types must be the same 
otherwise reloading is not possible and a redeploy is required).

The following code is an example of how to use +JProxy+ along with ItsNat web framework, this code is part of the example code of RelProxy source code and basically 
is the same as the Groovy example:


[source,java]
----
public static void init(ItsNatHttpServlet itsNatServlet,ServletConfig config)
{    
    ServletContext context = itsNatServlet.getItsNatServletContext().getServletContext();
    String inputPath = context.getRealPath("/") + "/WEB-INF/javaex/code/";           
    String classFolder = null; // Optional: context.getRealPath("/") + "/WEB-INF/classes";
    Iterable<String> compilationOptions = Arrays.asList(new String[]{"-source","1.6","-target","1.6"});
    long scanPeriod = 200;

    RelProxyOnReloadListener proxyListener = new RelProxyOnReloadListener() {
        public void onReload(Object objOld, Object objNew, Object proxy, Method method, Object[] args) {
            System.out.println("Reloaded " + objNew + " Calling method: " + method);
        }        
    };

    JProxyDiagnosticsListener diagnosticsListener = new JProxyDiagnosticsListener()
    {
        public void onDiagnostics(DiagnosticCollector<JavaFileObject> diagnostics)
        {
            List<Diagnostic<? extends JavaFileObject>> diagList = diagnostics.getDiagnostics();                
            int i = 1;
            for (Diagnostic diagnostic : diagList)
            {
               System.err.println("Diagnostic " + i);
               System.err.println("  code: " + diagnostic.getCode());
               System.err.println("  kind: " + diagnostic.getKind());
               System.err.println("  line number: " + diagnostic.getLineNumber());                   
               System.err.println("  column number: " + diagnostic.getColumnNumber());
               System.err.println("  start position: " + diagnostic.getStartPosition());
               System.err.println("  position: " + diagnostic.getPosition());                   
               System.err.println("  end position: " + diagnostic.getEndPosition());
               System.err.println("  source: " + diagnostic.getSource());
               System.err.println("  message: " + diagnostic.getMessage(null));
               i++;
            }
        }
    };

    JProxyConfig jpConfig = JProxy.createJProxyConfig();
    jpConfig.setEnabled(true)
            .setRelProxyOnReloadListener(proxyListener)
            .setInputPath(inputPath)
            .setScanPeriod(scanPeriod)
            .setClassFolder(classFolder)
            .setCompilationOptions(compilationOptions)
            .setJProxyDiagnosticsListener(diagnosticsListener);

    JProxy.init(jpConfig);


    String pathPrefix = context.getRealPath("/") + "/WEB-INF/javaex/pages/";

    ItsNatDocumentTemplate docTemplate;
    docTemplate = itsNatServlet.registerItsNatDocumentTemplate("javaex","text/html", pathPrefix + "javaex.html");

    FalseDB db = new FalseDB();

    ItsNatServletRequestListener listener = JProxy.create(new example.javaex.JProxyExampleLoadListener(db), ItsNatServletRequestListener.class);
    docTemplate.addItsNatServletRequestListener(listener);
} 
----

There is more code than Groovy code because +GroovyScriptEngine+ setting up was omitted (not specific of RelProxy) and now some configuration options are shown in spite of they may 
be optional.

Let's explain the previous code:

[source,java]
----
    JProxyConfig jpConfig = JProxy.createJProxyConfig();
    jpConfig.setEnabled(true)
            .setRelProxyOnReloadListener(proxyListener)
            .setInputPath(inputPath)
            .setScanPeriod(scanPeriod)
            .setClassFolder(classFolder)
            .setCompilationOptions(compilationOptions)
            .setJProxyDiagnosticsListener(diagnosticsListener);

    JProxy.init(jpConfig);
----

This is an example of JProxy configuration.

* +setEnabled(boolean)+ configuration method is the same as +GProxy+, when setting to false other configuration options are ignored, there is no hot reload and proxying and performance penalty is zero.

* +setRelProxyOnReloadListener(proxyListener)+ is the same as +GProxy+ in fact the same interface +RelProxyOnReloadListener+ is shared between +GProxy+ and +JProxy+.

* +setInputPath(inputPath)+ defines where the source code files of hot reloadable classes is.

* +setScanPeriod(scanPeriod)+ defines the period (in ms) between checks of timestamps of source code files to detect changes.

* +setClassFolder(classFolder)+ optionally defines where to save, as .class files, the bytecode resulting of re-compiling modified source files in runtime. 
By this way the next time the application is started .class files are aligned with source files and no runtime compilation is needed (class folder of course must be in
classpath).

* +setCompilationOptions(compilationOptions)+ optionally sets the list of options you want for compiling phase, these are the same kind of options you would provide to the
http://docs.oracle.com/javase/6/docs/technotes/tools/windows/javac.html[javac command], internally the 
http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html[Java compiler API] receives this parameters and the reason of the required format.

* +setJProxyDiagnosticsListener(diagnosticsListener)+ optionally registers the +JProxyDiagnosticsListener+ listener to be executed when some warning or error happens compiling
Java code, when providing null or not called RelProxy uses a default listener very similar to this example.


The final code:

[source,java]
----
    FalseDB db = new FalseDB();

    ItsNatServletRequestListener listener = JProxy.create(new example.javaex.JProxyExampleLoadListener(db), ItsNatServletRequestListener.class);
    docTemplate.addItsNatServletRequestListener(listener);
----

Is symmetric to Groovy counterpart, it is the same example and the same expected behavior of RelProxy but all in Java.

Anyway this is the code of +JProxyExampleLoadListener+:

[source,java]
.JProxyExampleLoadListener.java
----
package example.javaex;

import org.itsnat.core.event.ItsNatServletRequestListener;
import org.itsnat.core.ItsNatServletRequest;
import org.itsnat.core.ItsNatServletResponse;
import org.itsnat.core.html.ItsNatHTMLDocument;

public class JProxyExampleLoadListener implements ItsNatServletRequestListener
{
    protected FalseDB db;

    public JProxyExampleLoadListener() 
    { 
    }
    
    public JProxyExampleLoadListener(FalseDB db) 
    {
        this.db = db;
    }

    public void processRequest(ItsNatServletRequest request, ItsNatServletResponse response)
    { 
        System.out.println("JProxyExampleLoadListener 4 " + this.getClass().getClassLoader().hashCode());

        new example.javaex.JProxyExampleDocument(request,(ItsNatHTMLDocument)request.getItsNatDocument(),db);
    }
}
----

=== Start and stop source change detection

You can reduce to zero the footprint of RelProxy in production setting +setEnabled(boolean)+ to false, however if you are a brave guy or girl and you want to make also hot changes
in production... +JProxy.start()+ and +JProxy.stop()+ methods are for you.

Remember we must to define the period between source files checking for changes calling +setScanPeriod(scanPeriod)+, RelProxy defines behind the scene a +java.util.Timer+ for this task,
of course every time source code is checked needs some time, because there are synchronizations between source code cheking and proxies use a very small performance penalty happen
when checking source code. This is why we can +stop+ source code checking if we are not able to make source code changes reducing performance penalty to minimum, and we can call 
+start+ before performing some change.

You can call several times to +JProxy.start()+ and +JProxy.stop()+ methods, if nothing is going to be done nothing is done without errors (both methods return true
when a state change was effective), and they are thread safe.


== Configuring your Maven POM in a web project to use JProxy or GProxy

Probably JProxy and GProxy are going to be used frequently in web projects to avoid many tedious redeploys. In the case of ItsNat it can drastically reduce redeployments
regarding to markup design and view logic, just reloading the page ItsNat automatically reloads pure HTML templates involved when changed, with JProxy or GProxy view logic code 
is also reloaded without redeploying.

Because the web application needs to load the source code hot reloadable, this source code must be also distributed into the war file, that is, in some place below +WEB-INF/+ 
if you want to keep this code private, this folder or folders must be declared in POM to be copied to the war file by Maven.

At the time of writing RelProxy is not in a Maven repository, you must manually include in your dependencies.

The following POM is a simple example of a RelProxy (v0.8) ready web application including a public folder, +src/main/webapp/WEB-INF/code+, able to contain reloadable source code:

[source,xml]
.pom.xml
----
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.mycompany</groupId>
  <artifactId>relproxyexample</artifactId>
  <packaging>war</packaging>
  <version>1.0-SNAPSHOT</version>

  <name>relproxyexample</name>
  <url>http://maven.apache.org</url>

  <dependencies>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>servlet-api</artifactId>
      <version>2.5</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>jsp-api</artifactId>
      <version>2.1</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
        <groupId>relproxy</groupId>
        <artifactId>relproxy-jar</artifactId>
        <version>0.8</version>
        <scope>system</scope>
        <systemPath>${basedir}/src/main/webapp/WEB-INF/lib/relproxy-0.8.jar</systemPath>
    </dependency>

  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>2.0.2</version>
        <configuration>
          <source>1.6</source>
          <target>1.6</target>          
        </configuration>
      </plugin>
    </plugins>
    <resources>  
       <resource>
         <directory>src/main/webapp/WEB-INF/code</directory>         
       </resource>        
    </resources>     
  </build>

  
</project>
----

== Configuring Ant in NetBeans in a web project to use JProxy or GProxy

When creating a standard web project in NetBeans, the generated Ant files filter .java files when deploying, to avoid this filtering just add to the build.xml:

[source,xml]
.build.xml
----
    <target name="-pre-dist"> 
        <copy todir="${build.web.dir}/WEB-INF" preservelastmodified="true">
            <fileset dir="${webinf.dir}" /> 
        </copy>
    </target>     
----

== A new shell scripting language named Java

When we think on a shell scripting language we think on sh or csh, or maybe on the scripting language of Windows console (based on the old MSDOS), or maybe you know
your preferred conventional dynamic language usually can be executed like another shell language, for instance http://groovy.codehaus.org/Running[Groovy], 
http://www.linuxjournal.com/content/python-scripts-replacement-bash-utility-scripts[Python], http://stackoverflow.com/questions/166347/how-do-i-use-ruby-for-shell-scripting[Ruby]
or http://www.2ality.com/2011/12/nodejs-shell-scripting.html[JavaScript].

But when you think Java like a new shell scripting language sure you say "it's impossible".

No, it is possible, RelProxy includes a tool named *+jproxysh+* to make possible executing Java like another shell scripting language.

The principle is simple and is very similar to Groovy scripting, Groovy compiles on the fly Groovy code saving in memory the compiled bytecode, by this way developers
think Groovy script is interpreted and is not, the same approach is applied to Java through RelProxy. In the case of RelProxy, bytecode can be optionally saved as .class
files to avoid compiling on the fly every time the script is executed. When the JVM is able to load .class files instead of compiling execution maybe extremely faster
than conventional scripting languages interpreted line by line from sources, this is why the affirmation of Java as the fastest scripting language of the world is accurated.

=== Defining a Java based shell scripting file

Let's see the first example (some background of UNIX shell is supposed):

[source,java]
.example_java_shell
----
#!/usr/bin/env jproxysh

String msg = args.length > 0 ? args[0] : "";
System.out.println(msg);

System.out.println("example_java_shell 1 ");

example.javashellex.JProxyShellExample.exec();
----

The best way to think this script is like the content of the standard method +main+ of a class with some invented name in the default package (no package), in fact, 
this is how it is managed internally by RelProxy.

We could use +/bin/jproxysh+ or +/usr/local/bin/jproxysh+ but we are forced to install RelProxy in a concrete fixed place, by using +/usr/bin/env+ the command +jproxysh+ will be located
using the current PATH.

Save this file in a folder root of the dependent classes. The dependent class in this example is +JProxyShellExample+ (this example in RelProxy distribution includes more classes
but we are going to ignore them to simplify).

The hierarchy is:

++++
<pre>
&lt;root_folder&gt;
  example_java_shell           (file)
  example                      (folder)
    javashellex                (folder)
      JProxyShellExample.java  (file)
</pre>
++++


{nbsp} +
Yes, you are right, mentally adding the .java extension to +example_java_shell+ you get the typical file hierarchy of a JavaSE program. 


The first requisite is that +jproxysh+ must be accesible by the environment variable +PATH+, anyway executing this script is not direct, it requires some previous configuration:

* First of all the +JAVA_HOME+ environment variable is required. 
* The +CLASSPATH+ environment variable must locate the +relproxy-X.X.jar+ file and other folders and hards required by your Java application, conventions are the same than a typical JavaSE program.
* Optionally you may specify +JAVA_OPTS+ to provide options for the JVM.

There are other _optional_ environment variables in this case RelProxy specific:

* JPROXYSH_SCAN_PERIOD : defines the milliseconds between source code change checking, by default is -1 (no check) but a positive value is interesting when the script loads a server and JProxy (already configured) is used inside.
* JPROXYSH_CACHE_CLASS_FOLDER : defines where to save the .class files resulting of compiling on the fly the scripting code, this folder is automatically added to the class path, 
so when the script is loaded the second time the .class are used instead of source code acording to the typical source-binary timestamp rules (if source code is more recent the class is ignored and replaced with a new file).
* JPROXYSH_COMPILATION_OPTIONS : compilations passed to the JDK compiler, the format is the same as the command line +javac+.

The following is an example of shell code (into a script file) to execute the previous +example_java_shell+, this example is included in RelProxy distribution:

[source,sh]
.ex_java_shell_launcher.sh
----
#!/bin/sh

RELPROXY_JAR=relproxy-0.8.jar

PROJECT=`dirname $0`/..

if [ -z "$JAVA_HOME" ]; then 
    echo Missing JAVA_HOME environment variable, exiting...
    exit 1
fi

export PATH=$PATH:$PROJECT/bin
export CLASSPATH=$PROJECT/lib/$RELPROXY_JAR
export JAVA_OPTS="-client -Xmx100m"
# Nothing really required in JAVA_OPTS, just to test

export JPROXYSH_SCAN_PERIOD=-1
export JPROXYSH_CACHE_CLASS_FOLDER="$PROJECT/tmp/java_shell_test_classes"
export JPROXYSH_COMPILATION_OPTIONS="-source 1.6 -target 1.6"

$PROJECT/cmd_examples/code/example_java_shell "HELLO WORLD!"
----

Because +example_java_shell+ is a +jproxysh+ based script, nothing prevents of being executed directly using +jproxysh+:

[source,sh]
----
jproxysh $PROJECT/cmd_examples/code/example_java_shell "HELLO WORLD!"
----



=== Defining a complete Java class

As you have seen in +example_java_shell+ example, you can access to other Java "scripting" classes from the initial scripting file, this is really interesting when your scripts 
become too large and you need state (attributes) more methods and so on, that is, you need more classes.

But in case most of or completely your code can be in just one class, or the main scripting file needs to be more structured, you have the option of defining a conventional class
in the scripting main file.

Take a look to this example also included in RelProxy distribution (slightly modified):

[source,sh]
.example_java_shell_complete_class
----
#!/usr/bin/env jproxysh

import example.javashellex.JProxyShellExample;

public class example_java_shell_complete_class
{
    public static void main(String[] args)
    {
        String msg = args.length > 0 ? args[0] : "";
        System.out.println(msg);

        System.out.println("example_java_shell_complete_class 1 ");

        JProxyShellExample.exec();
    }
}
----

+example_java_shell_complete_class+ is a conventional class, you can add methods, attributes and so on, the only limitation is the name of the class, it must be the same as the container file
that is, the same as conventional JavaSE programming.

You can execute this script by the same ways we executed +example_java_shell+, directly or as a parameter of +jproxysh+.

=== Scripting conventional JavaSE source code

The differences between a the +example_java_shell_complete_class+ script and a conventional Java source file are just the extension (missing) and the hash bang to execute jproxysh.

We can remove the hashbang and set a +.java+ extension to the main scripting file, in this scenario the source code is the same as a conventional JavaSE application.
Instead of compiling with +javac+ and executing with +java+ command, you just must execute with +jproxysh+

[source,sh]
----
jproxysh $PROJECT/cmd_examples/code/example_normal_class.java "HELLO WORLD!"
----


=== Executing a Java code snippet

You have done some powerful Java methods, these Java methods allows some combinations to make easily amazing things, you just need one, or two or just three sentences... 
you don't need to create a Java shell scripting file, you just want to write down and execute. RelProxy through +jproxy+ allows executing Java code snippets on the fly.

The following is a shell script included in RelProxy distribution which executes a simple code snippet (the param +-c+ indicates you are going to execute inline code):

[source,sh]
.ex_java_shell_snippet_launcher.sh
----
#!/bin/sh

RELPROXY_JAR=relproxy-0.8.jar

PROJECT=`dirname $0`/..

if [ -z "$JAVA_HOME" ]; then 
    echo Missing JAVA_HOME environment variable, exiting...
    exit 1
fi

export PATH=$PATH:$PROJECT/bin
export CLASSPATH=$PROJECT/lib/$RELPROXY_JAR
export JAVA_OPTS="-client -Xmx100m"
# Nothing really required in JAVA_OPTS, just to test

export JPROXYSH_COMPILATION_OPTIONS="-source 1.6 -target 1.6"

jproxysh -c 'System.out.print("This code snippet says: ");' \
            'System.out.println("Hello World!!");'
----

You can execute a single code block (into a string parameter) or several blocks in several lines separated with "\", every block can contain several Java sentences.

=== The interactive Java shell

When you need something more interactive, just like the Groovy shell, RelProxy provides a simple interactive shell. 

To launch the interactive shell define the required environment variables like the code snippet example and execute +jproxysh+ with no parameters:

[source,sh]
----
jproxysh
----

A message info is shown and a prompt is shown waiting for your commands and or code. Write 'help' to know the shell options, if the text written is not recognized like a command
it is interpreted as Java code and saved in a buffer to be executed when you want writting the 'exec' command.

=== How to use RelProxy shell scripting in Windows

RelProxy does not provide a +jproxysh+ version for Windows because you can easily build a mini-Linux/Unix in your Windows box with http://www.mingw.org/[MinGW/MSYS].

Install MinGW/MSYS, you must be able to locate the shell launcher +msys.bat+ in a folder like +C:\MinGW\msys\1.0\+ (exact location may change according to your installation folder).

Execute +msys.bat+ and you will get a simple Linux shell environment, in this environment you can execute your typical Linux commands like +ls+, +ps+, +find+ etc and of course
launch the previous script files documented in this manual and included in RelProxy distribution.

MSYS console is enough for most of purposes, if you also install +mintty+ using the MinGW GUI or command based installer, calling +mintty&+ in MSYS opens an even more sophisticated
Linux console. Mintty has some problem with some keyboard characters editing Java code in the RelProxy interactive console, back to basic MSYS console when necesssary.

If you need to execute Linux shell scripts (for instance RelProxy based) from Windows without a Linux like interactive console, do something like this in your Windows script or console:

[source,sh]
----
set PATH=C:\MinGW\msys\1.0\bin;%PATH%
sh <path to the shell file>
----

Where +<path to the shell file>+ can have Windows or Linux format (e.g. +/c/development/relproxy/cmd_examples/ex_java_shell_launcher.sh+).

