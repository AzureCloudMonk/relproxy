// :icons: font es necesario para que se considere en la generación de HTML usando Font Awesome en donde palabras especiales son iconos por ej en "NOTE:" "IMPORTANT:" etc 
:icons: font  
// :linkcss: por defecto está definida por si acaso, para linkar asciidoctor.css
:linkcss:
// :copycss: es para que copie el asciidoctor.css por defecto junto al HTML generado
:copycss:
// :sectanchors: para mostrar un link de "posicionar" arriba cada título
:sectanchors:
:toc2:
// usamos highlightjs o prettify porque coderay falla (aunque está incluido)
:source-highlighter: prettify

= RelProxy
(C) Jose María Arranz Santamaría
v0.8

Because Java is also a dynamic language and Groovy can remain a dynamic language in a Java based environment.

== The origins of RelProxy

RelProxy was born as the result of the intent of providing a way to hot class reloading for the http://www.itsnat.org[ItsNat] Java web framework. 

ItsNat templates are pure X/HTML/SVG files with no logic executed in server, when a template is changed ItsNat automatically reloads the file and the new version is used 
in the next attempt of using the template. View logic is coded in Java by using Java W3C DOM APIs modifying ItsNat templates and finally generating the required markup in load
time or JavaScript code as the result of AJAX events.

As said before, ItsNat provided hot reloading of markup templates but view logic, coded in Java, remained too static, if you needed to change the view logic you needed to redeploy
the web application (in the best case only the web context is reloaded). Providing some hot class reloading of view logic (coded in Java or Groovy as we will see later) would dramatically increase
the productivity of ItsNat in development and in an edge case, view logic changes would be possible in production.

Redeploying is not strange to Java web developers when you leave the world of JSPs, JSPs were designed to be hot reloaded including logic coded in Java, many server centric frameworks
provides some kind of hot reloading templating, but in most of them Java code is not hot reloaded.

For ItsNat we needed some way to be able to hot reload view logic. The first attempt was trying to use Groovy in ItsNat, many people think Groovy is an "interpreted" language and is not, 
Groovy is also a language compiled to bytecode, but compilation happens on demand, generated bytecode is usually more flexible ("dynamic") than conventional Java and hot class reloading is built-in.
The problem of using Groovy in ItsNat was the need of registering Groovy listeners in ItsNat Java listeners (view processors), when registering
on an ItsNat (Java) listener the object registered is "frozen" and cannot be reloaded...

This was the context to invent RelProxy and is the reason of the name, Reload + Proxy, the first feature of RelProxy was creating Java proxies (+java.lang.reflect.Proxy+) to wrap Groovy objects before registering
into Java methods (ItsNat listeners), RelProxy proxies ever use the last version of the Groovy class by using the hot class loader of Groovy, by this way we can hot class reload classes in ItsNat... coded in Groovy.

The next step is obvious, Groovy class reloader is also a Groovy "compiler on demand", if we are able to make a "compiler on demand" for Java we can get THE SAME AS Groovy provides... in Java.
As you know, as of Java 1.6 we have a http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html[Java API] to access the compiler of your JDK.

If we are able to compile and load on demand Java source files, we can be more ambitious and be able to execute Java programs with no need of a previous compilation, and with no 
much problem package the start Java code like a UNIX shell script in a similar way http://groovy.codehaus.org/Running[Groovy does], providing maybe the fastest "scripting" language of the world. 

Why are you going to need Java as a scripting/shell language? 

Because:

. Java is faaaast
. Java is robust: because there is compilation on the fly, syntax errors are detected with no need of executing the offending code.
. Java has an enormous amount of libraries
. class files can be optionally automatically saved to avoid compilation in the next execution
. Java 8 is around the corner providing a less verbose language

If you can execute uncompiled Java code, is there something similar to an interactive shell to execute Java code snippets? Yes of course.

Finally, do not confuse Java scripting provided by RelProxy with http://www.beanshell.org/[BeanShell], BeanShell is NOT Java, is a scripting language heavily inspired on Java < 1.5, 
for instance in BeanShell there is no support of Java 1.5 features like generics .

That is all, welcome to dynamic Java, welcome to a more dynamic Groovy in a Java environment.
 
== What is RelProxy 

RelProxy is:

. A simple Java and Groovy hot class reloader for Java and Groovy providing transparent compilation and class reload on the fly with no need of a bootstrap class loader agent.
. A scripting environment to execute Java code snippets the same as a shell script, there is no new language, is Java compiled on the fly, code in the initial archive can call 
to other normal Java files. Optionally .class can be saved in a cache to provide *the fastest "scripting" language* of the world.
. Execution of Java code snippets in command line (no need of packaging into an archive).
. A simple shell to code, edit and execute code snippets in Java interactively.

== Requisites and installation

RelProxy requires a JDK 1.6 or upper, RelProxy have been tested on Oracle JDK 1.6 and OpenJDK 1.7.

RelProxy distribution file has two important files:

. relproxy-X.X.jar : needed in classpath to use RelProxy in any form. 
. jproxysh : whether command line scripting capabilities are to be used


== Registering hot reloadable Groovy objects in Java

+com.innowhere.relproxy.gproxy.GProxy+ is the main Java class of RelProxy to provide this feature, with +GProxy+ you can create Java proxies for Groovy objects because +java.lang.reflect.Proxy+ is passed instead of 
the original Groovy object, the original Groovy object is retained under the hood and method calls to the proxy are redirected to the real object calling the corresponding 
method using reflection. When the source code of the Groovy class changes GProxy automatically reloads the Groovy class and creates a new object to replace the old one, 
the fields of the original object are got and re-set to the new object to keep the state (number of fields and types must be the same otherwise reloading is not possible 
and a redeploy is required).

The following code is an example of how to use RelProxy along with ItsNat web framework, this code is part of the example code of RelProxy source code. 

The +servlet+ variable is a servlet object containing a just configured +groovy.util.GroovyScriptEngine+: 


[source,groovy]
.groovy_servlet_init.groovy
----
package example.groovyex;

import org.itsnat.core.http.ItsNatHttpServlet;
import org.itsnat.core.tmpl.ItsNatDocumentTemplate;
import org.itsnat.core.event.ItsNatServletRequestListener;
import groovy.util.GroovyScriptEngine;
import java.lang.reflect.Method;
import com.innowhere.relproxy.RelProxyOnReloadListener;
import com.innowhere.relproxy.gproxy.GProxy;
import com.innowhere.relproxy.gproxy.GProxyGroovyScriptEngine;
import com.innowhere.relproxy.gproxy.GProxyConfig;


GroovyScriptEngine groovyEngine = servlet.getGroovyScriptEngine();

def gproxyGroovyEngine = {
             String scriptName -> return (java.lang.Class)groovyEngine.loadScriptByName(scriptName) 
        } as GProxyGroovyScriptEngine;

def reloadListener = { 
        Object objOld,Object objNew,Object proxy, Method method, Object[] args -> 
           println("Reloaded " + objNew + " Calling method: " + method)
      } as RelProxyOnReloadListener;

def gpConfig = GProxy.createGProxyConfig();
gpConfig.setEnabled(true)
        .setRelProxyOnReloadListener(reloadListener)
        .setGProxyGroovyScriptEngine(gproxyGroovyEngine);

GProxy.init(gpConfig);


def db = new FalseDB();

String pathPrefix = context.getRealPath("/") + "/WEB-INF/groovyex/pages/";

def docTemplate;
docTemplate = itsNatServlet.registerItsNatDocumentTemplate("groovyex","text/html", pathPrefix + "groovyex.html");

ItsNatServletRequestListener listener = GProxy.create(new example.groovyex.GroovyExampleLoadListener(db), ItsNatServletRequestListener.class);
docTemplate.addItsNatServletRequestListener(listener);

----


Let's explain the previous code:

[source,groovy]
----
def gproxyGroovyEngine = {
             String scriptName -> return (java.lang.Class)groovyEngine.loadScriptByName(scriptName) 
        } as GProxyGroovyScriptEngine;
----

Defines a listener needed by GProxy to indirectly call the +groovy.util.GroovyScriptEngine+ to load classes, take a look to the signature of +GProxyGroovyScriptEngine+ there is no dependency
with +groovy.*+ packages, this is why you can use RelProxy in pure Java projects with no Groovy dependency in spite of Groovy support.


[source,groovy]
----
def reloadListener = { 
        Object objOld,Object objNew,Object proxy, Method method, Object[] args -> 
           println("Reloaded " + objNew + " Calling method: " + method)
      } as RelProxyOnReloadListener;
----

Defines an optional listener to be called when a Groovy class is reloaded, the listener receives the old and new object cause of reloading because a proxied method was called.

[source,groovy]
----
def gpConfig = GProxy.createGProxyConfig();
gpConfig.setEnabled(true)
        .setRelProxyOnReloadListener(reloadListener)
        .setGProxyGroovyScriptEngine(gproxyGroovyEngine);

GProxy.init(gpConfig);
----

Configures +GProxy+, now it is ready to proxy Groovy objects.

Take a look to the optional +setEnabled(true)+ configuration call, +GProxy+ is enabled by default, this means proxied Groovy objects are instrumented for hot reload. 
Calling +setEnabled(false)+ tells +GProxy+ to ignore any other configuration, +GProxy+ is disabled and no proxy is created, the original Groovy objects will be returned with absolute no performance penalty,
this is the preferred configuration in production whether you do not want hot class reload in production.

The final code:

[source,groovy]
----
def db = new FalseDB();

ItsNatServletRequestListener listener = GProxy.create(new example.groovyex.GroovyExampleLoadListener(db), ItsNatServletRequestListener.class);
docTemplate.addItsNatServletRequestListener(listener);
----

is an example of proxying a +example.groovyex.GroovyExampleLoadListener+ object and registering the returned Java proxy into the ItsNat infrastructure. 
The class +example.groovyex.GroovyExampleLoadListener+ implements the ItsNat standard interface +ItsNatServletRequestListener+ implementing the method
+processRequest(ItsNatServletRequest request, ItsNatServletResponse response)+ this method is called by ItsNat, the proxy object receives this call and forwards this call
to the latest class loaded, we are going to see more details later.

Let's go to take a look to +example.groovyex.GroovyExampleLoadListener+:

[source,groovy]
----
package example.groovyex;

import org.itsnat.core.event.ItsNatServletRequestListener;
import org.itsnat.core.ItsNatServletRequest;
import org.itsnat.core.ItsNatServletResponse;
import example.groovyex.FalseDB;

class GroovyExampleLoadListener implements ItsNatServletRequestListener
{
    def db

    GroovyExampleLoadListener() 
    { 
    }
    
    GroovyExampleLoadListener(FalseDB db) // Explicit type tells Groovy to reload FalseDB class when changed
    {
        this.db = db;
    }

    void processRequest(ItsNatServletRequest request, ItsNatServletResponse response)
    { 
        println("GroovyExampleLoadListener 4 ");
        
        new example.groovyex.GroovyExampleDocument(request.getItsNatDocument(),db);
    }
}
----

When RelProxy (through +groovy.util.GroovyScriptEngine+) detects the source code of the class +GroovyExampleLoadListener+ or dependent classes like +GroovyExampleDocument+ have 
changed, all of changed classes are reloaded and a new ClassLoader is created for them, next calls to +GroovyExampleLoadListener+ proxy will use the new loaded class and the same
with dependent classes.

However a concrete +GroovyExampleLoadListener+ object was used to register, how can we reload a class with one alive object already created?

The +GroovyExampleLoadListener+ object was the one proxied, this class is reloaded when the source change is detected (or any related class) because this is the objective, 
but this object can have fields pointing to objects usually loaded BEFORE registering/proxying the +GroovyExampleLoadListener+ object. In spite of the classes of these 
objects may be reloaded the new version is not effective because (not proxied) created objects are being used in other places. This is the case of the +db+ attribute of 
class +FalseDB+, this attribute references a concrete +FalseDB+ object not able to be automatically reloaded. In case of the proxied object +GroovyExampleLoadListener+, 
RelProxy recreates the object based on the new loaded class by calling the default constructor and *re-set the attributes*, by this way the new object is based on the new
class containing the same attribute objects defined. 

The proxied class usually creates new objects based on dependent classes to execute some task, if no object of these dependent classes is "saved" and/or used outside of proxied environment
RelProxy can reload dependent classes with no problem.

This is the case of the class +GroovyExampleDocument+ and dependent classes (see the source code).

Other classes and interfaces like +ItsNatServletRequest+ or +ItsNatServletResponse+ are not reloaded in this example because they are ItsNat based and source code is not
present in Groovy environment. +FalseDB+ class could be reloaded but reloading will fail because a shared attribute +db+ points to an object created before, RelProxy 
will say you the reloading process has been failed and a redeploy is recommended to effectively use the new version of the class.





