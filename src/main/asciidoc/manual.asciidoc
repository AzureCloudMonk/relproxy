// :icons: font es necesario para que se considere en la generación de HTML usando Font Awesome en donde palabras especiales son iconos por ej en "NOTE:" "IMPORTANT:" etc 
:icons: font  
// :linkcss: por defecto está definida por si acaso, para linkar asciidoctor.css
:linkcss:
// :copycss: es para que copie el asciidoctor.css por defecto junto al HTML generado
:copycss:
// :sectanchors: para mostrar un link de "posicionar" arriba cada título
:sectanchors:
:toc2:
// usamos highlightjs o prettify porque coderay falla (aunque está incluido)
:source-highlighter: prettify

= RelProxy
Jose María Arranz Santamaría
v0.8

Because Java is also a dynamic language and Groovy can remain a dynamic language in a Java based environment.

== The origins of RelProxy

RelProxy was born as the result of the intent of providing a way to hot class reloading for the http://www.itsnat.org[ItsNat] Java web framework. 

ItsNat templates are pure X/HTML/SVG files with no logic executed in server, when a template is changed ItsNat automatically reloads the file and the new version is used 
in the next attempt of using the template. View logic is coded in Java by using Java W3C DOM APIs modifying ItsNat templates and finally generating the required markup in load
time or JavaScript code as the result of AJAX events.

As said before, ItsNat provided hot reloading of markup templates but view logic, coded in Java, remained too static, if you needed to change the view logic you needed to redeploy
the web application (in the best case only the web context is reloaded). Providing some hot class reloading of view logic (coded in Java or Groovy as we will see later) would dramatically increase
the productivity of ItsNat in development and in an edge case, view logic changes would be possible in production.

Redeploying is not strange to Java web developers when you leave the world of JSPs, JSPs were designed to be hot reloaded including logic coded in Java, many server centric frameworks
provides some kind of hot reloading templating, but in most of them Java code is not hot reloaded.

For ItsNat we needed some way to be able to hot reload view logic. The first attempt was trying to use Groovy in ItsNat, many people think Groovy is an "interpreted" language and is not, 
Groovy is also a language compiled to bytecode, but compilation happens on demand, generated bytecode is usually more flexible ("dynamic") than conventional Java and hot class reloading is built-in.
The problem of using Groovy in ItsNat was the need of registering Groovy listeners in ItsNat Java listeners (view processors), when registering
on an ItsNat (Java) listener the object registered is "frozen" and cannot be reloaded...

This was the context to invent RelProxy and is the reason of the name, Reload + Proxy, the first feature of RelProxy was creating Java proxies (+java.lang.reflect.Proxy+) to wrap Groovy objects before registering
into Java methods (ItsNat listeners), RelProxy proxies ever use the last version of the Groovy class by using the hot class loader of Groovy, by this way we can hot class reload classes in ItsNat... coded in Groovy.

The next step is obvious, Groovy class reloader is also a Groovy "compiler on demand", if we are able to make a "compiler on demand" for Java we can get THE SAME AS Groovy provides... in Java.
As you know, as of Java 1.6 we have a http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html[Java API] to access the compiler of your JDK.

If we are able to compile and load on demand Java source files, we can be more ambitious and be able to execute Java programs with no need of a previous compilation, and with no 
much problem package the start Java code like a UNIX shell script in a similar way http://groovy.codehaus.org/Running[Groovy does], providing maybe the fastest "scripting" language of the world. 

Why are you going to need Java as a scripting/shell language? 

Because:

. Java is faaaast
. Java is robust: because there is compilation on the fly, syntax errors are detected with no need of executing the offending code.
. Java has an enormous amount of libraries
. class files can be optionally automatically saved to avoid compilation in the next execution
. Java 8 is around the corner providing a less verbose language

If you can execute uncompiled Java code, is there something similar to an interactive shell to execute Java code snippets? Yes of course.

Finally, do not confuse Java scripting provided by RelProxy with http://www.beanshell.org/[BeanShell], BeanShell is NOT Java, is a scripting language heavily inspired on Java < 1.5, 
for instance in BeanShell there is no support of Java 1.5 features like generics .

That is all, welcome to dynamic Java, welcome to a more dynamic Groovy in a Java environment.
 



////
PRUEBAS

[source,java]
.app.java
----
public void hola()
{
  int i = 10;
  String a = "Hola";
  System.out.println("Adios");
}
----

////

